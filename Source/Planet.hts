
require('meteor');

//

Planet = #;

//

Planet.CORE_SIDES = 32;
Planet.CORE_RADIUS = 50;

Planet.MANTLE_SIDES = 32;
Planet.MANTLE_RADIUS = 100;

Planet.CRUST_SIDES = 64;
Planet.CRUST_RADIUS = 150;

Planet.IMPACT_HIGH = 0.9;
Planet.IMPACT_MED = 0.7;
Planet.IMPACT_LOW = 0.3;

Planet.ROTATION_SPEED = 50;

//

Planet.New = function()
{
	let planet = #;

	Planet.CreateCrust(planet);

	planet.rotation = 0;

	planet.max_point = Planet.CRUST_RADIUS;

	return planet;
};

//

Planet.CreateCrust = function(planet)
{
	let vertices = #;
	let indices = #;

	table.insert(vertices, #{ 0, 0 });

	for(let i = 2 ... Planet.CRUST_SIDES + 1)
	{
		let h = math.rad(i * (360 / Planet.CRUST_SIDES));

		table.insert(vertices,#{
			math.cos(h) * Planet.CRUST_RADIUS,
			math.sin(h) * Planet.CRUST_RADIUS,
			Planet.CRUST_RADIUS, 0, 255, 255, 255, 255
		});
	}

	for(let i = 2 ... Planet.CRUST_SIDES)
	{
		table.insert(indices, 1);
		table.insert(indices, i + 1);
		table.insert(indices, i);
	}

	table.insert(indices, 1);
	table.insert(indices, 2);
	table.insert(indices, Planet.CRUST_SIDES + 1);

	planet.crust_mesh = love.graphics.newMesh(vertices, 'triangles', 'dynamic');

	planet.crust_mesh->setVertexMap(indices);
};

//

Planet.Update = function(planet, dt)
{
	if(love.keyboard.isDown('right'))
	{
		planet.rotation += (Planet.ROTATION_SPEED * dt);
	}
	else if(love.keyboard.isDown('left'))
	{
		planet.rotation -= (Planet.ROTATION_SPEED * dt);
	}

	if(planet.rotation < 360) { planet.rotation += 360; }
};

//

Planet.Draw = function(planet)
{
	love.graphics.push();
	love.graphics.rotate(math.rad(planet.rotation));

	love.graphics.draw(planet.crust_mesh, 0, 0);

	love.graphics.setColor(81, 63, 39, 255);
	love.graphics.circle('fill', 0, 0, Planet.MANTLE_RADIUS, Planet.MANTLE_SIDES);

	love.graphics.setColor(198, 73, 27, 255);
	love.graphics.circle('fill', 0, 0, Planet.CORE_RADIUS, Planet.CORE_SIDES);

	love.graphics.setColor(255, 255, 255, 255);
	love.graphics.pop();
};

//

Planet.Collides = function(planet, meteor)
{
	let max = planet.max_point * planet.max_point;
	
	let x = meteor.position.x;
	let y = meteor.position.y;

	if((x * x) + (y * y) > max) { return false, 0; }

	let r = math.fmod(math.deg(meteor.origin) - planet.rotation, 360);

	// Contains hack for collision index shift

	let i = Planet.SafeIndex(math.floor((Planet.CRUST_SIDES * r) / 360) - 2);

	let ix, iy = planet.crust_mesh->getVertexAttribute(i, 1);

	x = (x * x) - (ix * ix);
	y = (y * y) - (iy * iy);

	if((x + y) > Meteor.MIN_RADIUS * Meteor.MIN_RADIUS) { return false, 0; }

	return true, i;
};

//

Planet.GetHeight = function(i)
{
	return planet.crust_mesh->getVertexAttribute(Planet.SafeIndex(i), 2);
};

//

Planet.GetMaxHeight = function(planet)
{
	return planet.max_point;
};

//

Planet.Impact = function(planet, i, force)
{
	Planet.ImpactPoint(planet, i, force * Planet.IMPACT_HIGH);

	Planet.ImpactPoint(planet, i + 1, force * Planet.IMPACT_MED);
	Planet.ImpactPoint(planet, i - 1, force * Planet.IMPACT_MED);

	Planet.ImpactPoint(planet, i + 2, force * Planet.IMPACT_LOW);
	Planet.ImpactPoint(planet, i - 2, force * Planet.IMPACT_LOW);
};

//

Planet.ImpactPoint = function(planet, i, force)
{
	i = Planet.SafeIndex(i);

	let x, y = planet.crust_mesh->getVertex(i);
	let h = math.rad(i * (360 / (Planet.CRUST_SIDES - 1)));

	x += (math.cos(h) * force);
	y += (math.sin(h) * force);

	planet.crust_mesh->setVertexAttribute(i, 1, x, y);

	let dist = (x * x) + (y * y);

	planet.crust_mesh->setVertexAttribute(i, 2, dist, 0);

	if(dist > planet.max_point) { planet.max_point = dist; }
};

//

Planet.SafeIndex = function(i)
{
	while(i < 0) { i += Planet.CRUST_SIDES; }

	i = math.fmod(i, Planet.CRUST_SIDES);

	if(i == 0) { i = Planet.CRUST_SIDES; }

	return (i + 1);
};
