
require('meteor');
require('constants');

//

Planet = #;

//

Planet.CORE_SIDES = 32;
Planet.CORE_RADIUS = 5;

Planet.CRUST_SIDES = 64;
Planet.CRUST_RADIUS = 15;

Planet.IMPACT_HIGH = 0.9;
Planet.IMPACT_MED = 0.7;
Planet.IMPACT_LOW = 0.3;

Planet.ROTATION_SPEED = 50;

Planet.COLLISION_RADIUS = Meteor.MIN_RADIUS ^ 2;

Planet.LOGIC_RADIUS = (Planet.CRUST_SIDES / NB_OF_SECTORS) * 0.5;

Planet.WATER_SIDES = 32;

Planet.CRUST_R = 114;
Planet.CRUST_G = 84;
Planet.CRUST_B = 71;

Planet.ANIMAL_R = 60;
Planet.ANIMAL_G = 120;
Planet.ANIMAL_B = 163;

Planet.VEGETAL_R = 71;
Planet.VEGETAL_G = 145;
Planet.VEGETAL_B = 73;

Planet.SHROOM_R = 154;
Planet.SHROOM_G = 97;
Planet.SHROOM_B = 204;

//

Planet.New = function()
{
	let planet = #;

	Planet.CreateCrust(planet);

	planet.rotation = 0;

	planet.min_point = Planet.CRUST_RADIUS;
	planet.max_point = Planet.CRUST_RADIUS;

	planet.water_level = 0;
	planet.has_water = false;

	return planet;
};

//

Planet.CreateCrust = function(planet)
{
	let vertices = #;
	let indices = #;

	table.insert(vertices, #{ 0, 0, 0, 0,
		Planet.CRUST_R, Planet.CRUST_G, Planet.CRUST_B, 255
	});

	for(let i = 2 ... Planet.CRUST_SIDES + 1)
	{
		let h = math.rad(i * (360 / Planet.CRUST_SIDES));

		table.insert(vertices,#{
			math.cos(h) * Planet.CRUST_RADIUS,
			math.sin(h) * Planet.CRUST_RADIUS,
			Planet.CRUST_RADIUS, 0,
			Planet.CRUST_R, Planet.CRUST_G, Planet.CRUST_B, 255
		});
	}

	for(let i = 2 ... Planet.CRUST_SIDES)
	{
		table.insert(indices, 1);
		table.insert(indices, i + 1);
		table.insert(indices, i);
	}

	table.insert(indices, 1);
	table.insert(indices, 2);
	table.insert(indices, Planet.CRUST_SIDES + 1);

	planet.crust_mesh = love.graphics.newMesh(vertices, 'triangles', 'dynamic');

	planet.crust_mesh->setVertexMap(indices);
};

//

Planet.Update = function(planet, dt)
{
	if(love.keyboard.isDown('right'))
	{
		planet.rotation += (Planet.ROTATION_SPEED * dt);
	}
	else if(love.keyboard.isDown('left'))
	{
		planet.rotation -= (Planet.ROTATION_SPEED * dt);
	}

	if(planet.rotation < 360) { planet.rotation += 360; }
};

//

Planet.Draw = function(planet)
{
	love.graphics.push();
	love.graphics.rotate(math.rad(planet.rotation));

	love.graphics.setColor(75, 175, 209, 255);
	love.graphics.circle('fill', 0, 0, planet.water_level, Planet.WATER_SIDES);

	love.graphics.setColor(255, 255, 255, 255);
	love.graphics.draw(planet.crust_mesh, 0, 0);

	love.graphics.setColor(206, 184, 177, 255);
	love.graphics.circle('fill', 0, 0, Planet.CORE_RADIUS, Planet.CORE_SIDES);

	love.graphics.setColor(255, 255, 255, 255);
	love.graphics.pop();
};

//

Planet.Collides = function(planet, meteor)
{
	let max = planet.max_point * planet.max_point;
	
	let x = meteor.position.x;
	let y = meteor.position.y;

	if((x * x) + (y * y) > max) { return false, 0; }

	let r = math.fmod(math.deg(meteor.origin) - planet.rotation, 360);

	// Contains hack for collision index shift

	let i = Planet.SafeIndex(math.floor((Planet.CRUST_SIDES * r) / 360) - 2);

	let ix, iy = planet.crust_mesh->getVertexAttribute(i, 1);

	x = (x * x) - (ix * ix);
	y = (y * y) - (iy * iy);

	if((x + y) > Planet.COLLISION_RADIUS) { return false, 0; }

	return true, i;
};

//

Planet.GetHeight = function(planet, i)
{
	return planet.crust_mesh->getVertexAttribute(Planet.SafeIndex(i), 2);
};

//

Planet.GetMinHeight = function(planet)
{
	return planet.min_point;
};

//

Planet.GetMaxHeight = function(planet)
{
	return planet.max_point;
};

//

Planet.Impact = function(planet, i, force)
{
	Planet.ImpactPoint(planet, i, force * Planet.IMPACT_HIGH);

	Planet.ImpactPoint(planet, i + 1, force * Planet.IMPACT_MED);
	Planet.ImpactPoint(planet, i - 1, force * Planet.IMPACT_MED);

	Planet.ImpactPoint(planet, i + 2, force * Planet.IMPACT_LOW);
	Planet.ImpactPoint(planet, i - 2, force * Planet.IMPACT_LOW);
};

//

Planet.ImpactPoint = function(planet, i, force)
{
	i = Planet.SafeIndex(i);

	let x, y = planet.crust_mesh->getVertex(i);
	let h = math.rad(i * (360 / (Planet.CRUST_SIDES - 1)));

	x += (math.cos(h) * force);
	y += (math.sin(h) * force);

	planet.crust_mesh->setVertexAttribute(i, 1, x, y);

	let dist = (x * x) + (y * y);

	planet.crust_mesh->setVertexAttribute(i, 2, dist, 0);

	if(dist > planet.max_point) { planet.max_point = dist; }
	if(dist < planet.min_point) { planet.min_point = dist; }
};

//

Planet.SafeIndex = function(i)
{
	while(i < 0) { i += Planet.CRUST_SIDES; }

	i = math.fmod(i, Planet.CRUST_SIDES);

	if(i == 0) { i = Planet.CRUST_SIDES; }

	return (i + 1);
};

//

Planet.UpdateEffect = function(planet, i, ice, life, level)
{
	let r = Planet.CRUST_R;
	let g = Planet.CRUST_G;
	let b = Planet.CRUST_B;

	if(life == LIFE.ANIMAL)
	{
		r = Planet.ANIMAL_R;
		g = Planet.ANIMAL_G;
		b = Planet.ANIMAL_B;
	}
	else if(life == LIFE.VEGETAL)
	{
		r = Planet.VEGETAL_R;
		g = Planet.VEGETAL_G;
		b = Planet.VEGETAL_B;
	}
	else if(life == LIFE.MUSHROOM)
	{
		r = Planet.SHROOM_R;
		g = Planet.SHROOM_G;
		b = Planet.SHROOM_B;
	}

	if(ice > 0)
	{
		// TODO
	}

	Planet.SetColor(i, r, g, b);


};

//

Planet.RaiseWaterLevel = function(planet, delta)
{
	if(!planet.has_water)
	{
		planet.water_level = planet.min_point;
		planet.has_water = true;
	}

	planet.water_level += delta;

	if(planet.water_level < 0) { planet.water_level = 0; }
};
