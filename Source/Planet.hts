
require('constants');

//

Planet = #;

//

Planet.CRUST_SIDES = 64;
Planet.CRUST_RADIUS = 100;

Planet.IMPACT_HIGH = 0.9;
Planet.IMPACT_MED = 0.7;
Planet.IMPACT_LOW = 0.3;

//

Planet.New = function()
{
	let planet = #;

	Planet.CreateCrust(planet);

	return planet;
};

//

Planet.CreateCrust = function(planet)
{
	let vertices = #;
	let indices = #;

	table.insert(vertices, #{ 0, 0 });

	for(let i = 2 ... Planet.CRUST_SIDES)
	{
		let h = math.rad(i * (360 / (Planet.CRUST_SIDES - 1)));

		table.insert(vertices,#{
			math.cos(h) * Planet.CRUST_RADIUS,
			math.sin(h) * Planet.CRUST_RADIUS,
			0, 0, 255, 255, 255, 255
		});
	}

	for(let i = 2 ... Planet.CRUST_SIDES - 1)
	{
		table.insert(indices, 1);
		table.insert(indices, i + 1);
		table.insert(indices, i);
	}

	table.insert(indices, 1);
	table.insert(indices, 2);
	table.insert(indices, Planet.CRUST_SIDES);

	planet.crust_mesh = love.graphics.newMesh(vertices, 'triangles', 'dynamic');

	planet.crust_mesh->setVertexMap(indices);
};

//

Planet.Draw = function(planet)
{
	love.graphics.draw(planet.crust_mesh,Constants.CENTER.x,Constants.CENTER.y);
};

//

Planet.Impact = function(planet, i, force)
{
	Planet.ImpactPoint(planet, i, force * Planet.IMPACT_HIGH);

	Planet.ImpactPoint(planet, i + 1, force * Planet.IMPACT_MED);
	Planet.ImpactPoint(planet, i - 1, force * Planet.IMPACT_MED);

	Planet.ImpactPoint(planet, i + 2, force * Planet.IMPACT_LOW);
	Planet.ImpactPoint(planet, i - 2, force * Planet.IMPACT_LOW);
};

//

Planet.ImpactPoint = function(planet, i, force)
{
	if(i > Planet.CRUST_SIDES) { i -= Planet.CRUST_SIDES + 1; }
	if(i < 2) { i += Planet.CRUST_SIDES; }

	let x, y = planet.crust_mesh->getVertex(i);
	let h = math.rad(i * (360 / (Planet.CRUST_SIDES - 1)));

	planet.crust_mesh->setVertexAttribute(i, 1,
		x + (math.cos(h) * force),
		y + (math.sin(h) * force)
	);
};
